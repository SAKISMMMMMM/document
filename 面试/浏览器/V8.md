### V8 垃圾回收机制

JavaScript 数据类型分为基础类型和引用类型,首先我们来看下他们存放数据的位置

- 基础类型 (栈内存)
- 引用类型(栈内存仅储存内存指针,内存指针指向堆内存中的对象空间,通过引用地址来访问)

#### 为什么需要垃圾回收？

简单来说,V8 能使用的内存是有限的(64 位:1464M,32 位:732M),就是基础类型的栈内存可以让系统自动分配释放回收,但是堆内存因为大小不固定等原因,需要 JS 引擎去管理这部分内存,减少系统性能下降概率,提高运行效率.

#### 回收算法分类

- 副垃圾回收器。主要负责新生代的垃圾回收(Scavenge 算法)
- 主垃圾回收器。主要负责老生代的垃圾回收(Mark-Sweep && Mark-Compact 算法)

#### 阶段详解

##### 新生代

在 JS 对象声明分配到的内存,都先放到新生代中处理,具体做法如下:

- Scavenge 算法吧把新生代堆划分两部分,from & to

- 当 from 区域放满时,就会对依然处于活动状态的对象内存进行标记,标记完成后把 from 带有标记的对象复制到 to 内并有序存放起来,然后清除掉剩下非活动状态的对象内存

- 完成清除后, from 和 to 内存互换

**知识点: 如何判断是不是活动对象呢？**

- 可达性,从根对象指针开始搜索,如果子节点可以搜索到,证明引用对象仍处于活动状态,就标记为活动对象

- 新生代经历两次 Scavenge 算法仍存在的话,就会晋升至老生代

##### 老生代

老生代内存垃圾回收机制分两个阶段分别为**Mark-Sweep(标记清理)**和**Mark-Compact(标记整理)**

- Mark-Sweep(标记清理)

**标记**对老生代对象进行扫描,将能到达的对象标记为活动对象,扫描结束后**清除**未标记的非活动对象

- Mark-Compact(标记整理)

清除了非活动对象后,会产生大量不连续的内存碎片,会导致需要大内存的对象需要花时间寻找内存空位,这时候就需要**Mark-Compact(标记整理)**来进行内存碎片的整理了,整理阶段，每次清理完非活动对象，就会把活动对象整理到内存的一端,然后清除掉端边界以外的内存

**为什么老生代不使用 Scavenge 算法?**

因为 Scavenge 算法 需要复制,只能应用于空间比较少的新生代内存中

#### 全停顿

因为 JS 代码运行需要 JS 引擎,垃圾回收也需要用到 JS 引擎,当两者同时进行时,将优先垃圾回收运行,当垃圾回收优先运行时,JS 代码停止的时候,就叫做全停顿。

当某些特殊时候,造成老生代垃圾回收处理时间比较长时,会造成停顿时间较长,这时候页面会出现卡顿情况

#### 优化策略

为了处理全停顿的情况,V8 出现了增量标记\惰性清理\并发\并行等优化策略

- 增量标记:

当需要清楚的内存垃圾超过一定界限时,会开启增量标记,可以标记一点,JS 运行一下,减少浏览器的卡顿情况

- 惰性清理:

在增量标记后,如余下内存足够流畅运行 JS,那就选择先不清理或先清理整理部分内存,提高浏览器的体验,但是这时候会出现一个问题,如果内存标记或者清理过程中,当标记未活动的对象活动了起来,或者已经标记了活动的对象被 JS 代码设置为非活动对象,会造成标记错误的情况,这时候就需要**屏障技术**来避免了

- 并发

顾名思义,就是在垃圾回收时不影响主线程运行,只是需要在某些特殊时刻暂停主线程运行,提高 JS 引擎效率.

- 并行

使主线程和辅助线程同时执行相同的 GC 工作,不过可能存在活动对象被不同线程复制的情况

## 参考文献

- [x] [赠你 13 张图，助你 20 分钟打败了「V8 垃圾回收机制」！！！(Sunshine_Lin)](https://juejin.cn/post/6995706341041897486)

- [x] [垃圾回收(jsLiang)](https://github.com/LiangJunrong/document-library/blob/master/%E7%B3%BB%E5%88%97-%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md)
